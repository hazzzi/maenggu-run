## 2025-01-17 - setup

**PRD**: setup (프로젝트 초기 설정)

**Completed**:
- electron-vite 프로젝트 구조: src/main, src/preload, src/renderer, src/shared
- 공유 타입 정의: SaveData, SnackState, MaengguState (src/shared/types.ts)
- BrowserWindow 기본 설정: transparent, frame:false, alwaysOnTop, hasShadow:false

**Files**:
- src/shared/types.ts (new)
- src/shared/constants.ts (new)
- src/main/index.ts (new)
- src/preload/index.ts (new)
- src/renderer/App.tsx (new)

**Decisions**:
- electron-vite 템플릿 기반으로 시작
- TypeScript strict mode 활성화
- 공유 타입은 src/shared에 집중 관리

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass
- test: ⚠️ no tests yet (expected)

## 2025-01-17 - window-core

**PRD**: window-core (오버레이 창 기본 설정)

**Completed**:
- BrowserWindow 옵션 정의 (transparent, frame:false, alwaysOnTop, hasShadow:false, resizable:false)
- 전체 디스플레이 합산 영역 계산 로직 추가
- 오버레이 창 크기/위치에 합산 영역 적용
- setIgnoreMouseEvents(true, { forward: true }) 기본 적용

**Files**:
- src/main/index.ts (modified)

**Decisions**:
- macOS-only 타겟이므로 플랫폼 분기 없음
- 멀티모니터 지원을 위해 모든 디스플레이 bounds 합산
- 창 크기는 합산 영역 전체 (움직임 제약 없음)

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass
- test: ⚠️ no tests yet (expected)

## 2025-01-17 - window-mouse-main

**PRD**: window-mouse-main (클릭 통과 IPC - main process)

**Completed**:
- main: mouse:collider IPC 핸들러 등록
- main: inCollider=true면 setIgnoreMouseEvents(false) 적용
- main: inCollider=false면 setIgnoreMouseEvents(true, { forward: true }) 적용

**Files**:
- src/main/ipc/mouse.ts (new)
- src/main/index.ts (modified, registerMouseIpcHandlers 호출)

**Decisions**:
- IPC handlers를 src/main/ipc/ 폴더로 분리 (AGENTS.md 권장)
- inCollider 인자로 통과 여부 제어

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass
- test: ⚠️ no tests yet (expected)

## 2025-01-17 - preload-api-mouse

**PRD**: preload-api-mouse (preload API - mouse)

**Completed**:
- contextBridge에 mouse.setCollider API 노출
- preload → renderer 타입 선언

**Files**:
- src/preload/index.ts (modified, mouse API 추가)
- src/renderer/env.d.ts (new, Window.maenggu 타입)

**Decisions**:
- preload → renderer 타입은 env.d.ts로 분리

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass
- test: ⚠️ no tests yet (expected)
## 2025-01-17 - vite-plugin-electron 제거 (구조 마이그레이션)

**PRD**: 없음 (리팩터링)

**Completed**:
- vite-plugin-electron 제거
- 순수 electron-vite 빌드 구조로 마이그레이션
- 템플릿 데모 코드 완전 삭제 (react-logo.svg, App.css, index.css 등)
- 빈 App 컴포넌트로 시작 (앞으로 맹구 구현 예정)
- electron.vite.config.ts 수정

**Files**:
- electron.vite.config.ts (new)
- src/renderer/App.tsx (수정, 빈 컴포넌트)
- src/renderer/env.d.ts (new, Window.maenggu 타입)
- vite.config.ts (수정)
- tsconfig.json (수정)
- package.json (main entry 수정)
- 삭제: electron/, src/App.*, src/main.tsx, src/index.css, src/vite-env.d.ts, src/assets/, public/*.svg, index.html

**Decisions**:
- 구조 마이그레이션만 진행, vite-plugin-electron 유지
- 템플릿 데모 코드 완전 제거, 빈 App 컴포넌트로 시작
- preload → renderer 타입 참조를 src/renderer/env.d.ts에서 처리

## 2025-01-18 - save-load

**PRD**: save-load (저장 로드 흐름)

**Completed**:
- loadSaveData(): fs/promises로 저장 파일 읽기
- JSON 파싱 + ENOENT시 DEFAULT_SAVE_DATA 반환
- isValidSaveData(): 스키마 검증 (version, snacks, stats 필드)
- saveSaveData(): 저장 파일 쓰기 (mkdir recursive)
- IPC handler: save:load → ipcMain.handle로 등록
- preload: save.load() API 노출
- SaveLoadResult 타입 shared로 이동

**Files**:
- src/main/save.ts (new)
- src/main/ipc/save.ts (new)
- src/main/index.ts (registerSaveIpcHandlers 호출)
- src/preload/index.ts (save.load API 추가)
- src/shared/types.ts (SaveLoadResult 타입 추가)

**Decisions**:
- AGENTS.md 권장대로 IPC handlers를 src/main/ipc/ 분리
- 파일 없으면 에러 아닌 기본값 반환 (첫 실행 시나리오)
- schema validation 실패 시 error 반환 (save-error 카테고리에서 처리)
## 2025-01-18 - snack-state + preload-api-snack

**PRD**: snack-state (간식 상태 관리), preload-api-snack (preload API - snack)

**Completed**:
- SnackStateManager: in-memory state with add/spend/broadcast
- createSnackStateManager(): snacks counter + stats tracking
- getSnackState(): singleton pattern
- snack:add IPC handler (fire-and-forget)
- snack:spend IPC handler (returns boolean success)
- snack:update broadcast to all renderer windows
- preload: snack.add(), snack.spend(), snack.onUpdate() exposed
- main: initialize snack state from save on app start
- stats: totalClicks, totalFeedings, peakSnacks auto-updated

**Files**:
- src/main/snack-state.ts (new)
- src/main/ipc/snack.ts (new)
- src/main/index.ts (registerSnackIpcHandlers, loadSaveData → initializeFromSave)
- src/preload/index.ts (snack API added to MaengguApi)

**Decisions**:
- Singleton pattern for snack state (getSnackState)
- Broadcast pattern for state updates (IPC_CHANNELS.SNACK_UPDATE)
- onUpdate returns cleanup function (removeListener)
- add() increments totalClicks, spend() increments totalFeedings
- peakSnacks auto-tracked on add()

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ⚠️ no tests yet (expected)

## 2025-01-18 - save-debounce

**PRD**: save-debounce (저장 debounce)

**Completed**:
- debounce() utility function in src/shared/utils.ts (generic, typed, with cancel)
- save-scheduler.ts module: scheduleSave(), cancelPendingSave(), flushSave()
- scheduleSave() called after snack:add and snack:spend (on success only)
- flushSave() on app before-quit event to persist pending changes
- 500ms debounce delay from SAVE_DEBOUNCE_MS constant

**Files**:
- src/shared/utils.ts (new)
- src/main/save-scheduler.ts (new)
- src/main/ipc/snack.ts (modified, added scheduleSave calls)
- src/main/index.ts (modified, added flushSave on before-quit)

**Decisions**:
- Debounce util in shared/ for potential renderer reuse
- Only schedule save on successful spend (not failed attempts)
- flushSave cancels pending debounce then saves immediately on quit
- Error logging in performSave but non-blocking

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ⚠️ no tests yet (expected)
## 2025-01-18 - save-error

**PRD**: save-error (저장 손상 처리)

**Completed**:
- dialog.showMessageBox on load failure (type: error)
- Show error message with detail from saveResult.error
- app.quit() after dialog dismissed
- Blocking error: prevents window creation and app startup

**Files**:
- src/main/index.ts (added dialog import, error handling in app.whenReady)

**Decisions**:
- Block app startup on corrupted save (fail-fast principle)
- Single "Quit" button in error dialog (no recovery option)
- Error detail shown in dialog for debugging

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ⚠️ no tests yet (expected)
## 2025-01-18 - window-mouse-renderer

**PRD**: window-mouse-renderer (클릭 통과 콜라이더 - renderer)

**Completed**:
- useMouseCollider hook: tracks mouse position via window mousemove
- Bounds checking: getBoundingClientRect() collision detection
- State change optimization: only sends IPC when in/out state changes (via ref)
- Cleanup: resets collider state on unmount
- Placeholder Maenggu element: 64x64 semi-transparent div for testing
- pointerEvents: auto on Maenggu element (container remains none)

**Files**:
- src/renderer/hooks/useMouseCollider.ts (new)
- src/renderer/App.tsx (modified: added useRef, useMouseCollider, placeholder element)

**Decisions**:
- Custom hook pattern for reusability and separation of concerns
- useRef to track isInside state (avoids re-renders, only IPC on change)
- Placeholder styling inline (will be replaced by actual sprite rendering)
- Cleanup resets collider to false on unmount (prevents stuck state)

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ⚠️ no tests yet (expected)
## 2025-01-18 - anim-state

**PRD**: anim-state (애니메이션 상태 머신)

**Completed**:
- getNextAnimationState(): state transition guard + event mapping
- Defined AnimationEvent union for idle/walk/eat/happy transitions
- Added STATE_TRANSITIONS and EVENT_TO_STATE maps
- Unit tests for all transitions including invalid/force-idle

**Files**:
- src/renderer/animation/state-machine.ts (new)
- src/renderer/animation/state-machine.test.ts (new)

**Decisions**:
- Pure function + lookup tables for deterministic transitions
- Invalid events return current state (no-op)
- force-idle provides global override

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass
## 2025-01-18 - sprite-loader

**PRD**: sprite-loader (스프라이트 로딩)

**Completed**:
- Sprite manifest for idle/walk/eat/happy frames
- getSpriteManifest() returns readonly frame lists
- getSpriteFrameUrls(basePath) builds full URLs with base path
- Unit tests for manifest and URL generation

**Files**:
- src/renderer/animation/sprite-loader.ts (new)
- src/renderer/animation/sprite-loader.test.ts (new)

**Decisions**:
- Manifest stored in code, not loaded dynamically (fast, deterministic)
- Base path normalized with trailing slash handling
- assets/ prefix assumed for sprite folder

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass
## 2025-01-19 - prd-sync

**PRD**: Sync prd.json with actual progress

**Completed**:
- Updated prd.json: marked 6 completed tasks as passes=true
  - window-mouse-renderer
  - save-error
  - save-debounce
  - sprite-loader
  - anim-state
  - assets-sprites
- Verified sprite assets exist in ./assets/ (9 PNG files, 32x32, organized by state)
- Confirmed sprite-loader.ts matches actual sprite filenames

**Files**:
- prd.json (updated 6 task entries)

**Decisions**:
- Sprite assets already complete with proper structure
- All feedback loops pass (typecheck, lint, test)

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (9 tests in 2 files)
## 2025-01-19 - maenggu-init + assets-rendering

**PRD**: maenggu-init (맹구 초기화), assets-rendering (픽셀 렌더링 설정)

**Completed**:
- Maenggu component: forwardRef, sprite rendering via <img>
- useMaengguState hook: animState (idle), position (viewport center)
- Initial state 'idle' via useState default
- Initial position: window.innerWidth/2, window.innerHeight/2
- image-rendering: pixelated for crisp pixels
- SPRITE_SIZE * scale for fixed display size (64x64 at 2x scale)
- Symlinked public/assets -> ../assets for Vite serving

**Files**:
- src/renderer/components/Maenggu.tsx (new)
- src/renderer/hooks/useMaengguState.ts (new)
- src/renderer/App.tsx (modified: use Maenggu component)
- public/assets -> ../assets (symlink)

**Decisions**:
- forwardRef for collider detection compatibility
- Scale=2 (32px sprites → 64px display)
- Position is center-relative (left/top - size/2)
- Separate state hook for future movement integration

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (9 tests)
## 2025-01-19 - anim-idle + anim-walk

**PRD**: anim-idle (idle 애니메이션), anim-walk (walk 애니메이션)

**Completed**:
- useAnimation hook: state-driven frame cycling
- setInterval with ANIMATION_FRAME_DURATION_MS (200ms)
- Frame reset on animState change
- Single-frame optimization (skip interval if frameCount <= 1)
- Cleanup on unmount (clearInterval)
- Integrated with App.tsx and Maenggu component

**Files**:
- src/renderer/hooks/useAnimation.ts (new)
- src/renderer/App.tsx (modified: added useAnimation, pass frameIndex)

**Decisions**:
- Generic hook works for all animation states
- idle has 1 frame (no visible animation), walk has 3 frames
- eat/happy need completion callbacks (separate task)

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (9 tests)
## 2025-01-19 - tray-quit

**PRD**: tray-quit (트레이 종료 메뉴)

**Completed**:
- Tray creation with icon from idle sprite (mangoo_defatult.png)
- nativeImage.createFromPath + resize to 16x16 for tray
- Menu.buildFromTemplate with Quit item
- Quit calls app.quit() directly
- Tooltip: "Maenggu Run"

**Files**:
- src/main/index.ts (added Tray, Menu, nativeImage imports, createTray function)

**Decisions**:
- Reuse idle sprite as tray icon (16x16 resize)
- Single Quit menu item (minimal, focused)
- createTray called after createWindow in whenReady

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (9 tests)
## 2025-01-19 - anim-eat

**PRD**: anim-eat (eat 애니메이션)

**Completed**:
- Extended useAnimation hook with optional onComplete callback parameter
- Added LOOPING_STATES constant to distinguish looping vs one-shot animations
- One-shot animations (eat, happy) play once, call onComplete, stay at last frame
- Looping animations (idle, walk) cycle indefinitely
- App.tsx dispatches eat-finish event when eat animation completes
- Completion flag reset on animState change (allows re-triggering)
- 8 comprehensive tests for looping, one-shot, and state change scenarios

**Files**:
- src/renderer/hooks/useAnimation.ts (modified: added onComplete, looping logic)
- src/renderer/App.tsx (modified: handleAnimationComplete callback)
- src/renderer/hooks/useAnimation.test.ts (new: 8 tests)
- vitest.config.ts (new: test environment configuration)
- package.json (modified: added @testing-library/react, jsdom)

**Decisions**:
- Separated looping states (idle, walk) from one-shot states (eat, happy) via constant
- Used useRef to track completion flag (prevents multiple onComplete calls)
- onComplete fires after last frame displayed, not before
- Single-frame one-shot animations (happy) call onComplete immediately
- Tests use vi.useFakeTimers for deterministic frame timing

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (17 tests, 8 new for useAnimation)
## 2025-01-25 - anim-happy

**PRD**: anim-happy (happy 애니메이션)

**Completed**:
- Added happy-finish event dispatch in handleAnimationComplete
- Completes eat → happy → idle animation flow
- Happy uses existing one-shot animation infrastructure (from anim-eat)
- State machine already had happy-finish → idle transition

**Files**:
- src/renderer/App.tsx (modified: added happy case to handleAnimationComplete)

**Decisions**:
- Minimal change: only added else-if for happy state
- Reuses all infrastructure from anim-eat implementation
- No new tests needed: state-machine.test.ts already covers happy-finish transition

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (17 tests)
## 2025-01-25 - movement-idle-timer

**PRD**: movement-idle-timer (idle 타이머)

**Completed**:
- useIdleTimer hook: starts timer when entering idle state
- Random duration from IDLE_TIME_RANGE (3-8 seconds)
- Dispatches walk-start event when timer fires
- Timer cancels when leaving idle or on unmount
- Integrated with App.tsx

**Files**:
- src/renderer/hooks/useIdleTimer.ts (new)
- src/renderer/hooks/useIdleTimer.test.ts (new: 6 tests)
- src/renderer/App.tsx (modified: added useIdleTimer hook)

**Decisions**:
- Separate hook for single responsibility
- useRef for timer handle (prevents memory leaks)
- Timer resets on animState change via useEffect cleanup
- Random uses Math.random with range calculation

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (23 tests, 6 new for useIdleTimer)
## 2025-01-25 - movement-target

**PRD**: movement-target (이동 목적지 선정)

**Completed**:
- generateRandomTarget(): creates random position within screen bounds
- isPositionInBounds(): validates position is within valid range
- getWindowBounds(): gets current window dimensions
- Added moveTarget state to useMaengguState (Position | null)
- Added setMoveTarget action to useMaengguState

**Files**:
- src/renderer/movement/target.ts (new)
- src/renderer/movement/target.test.ts (new: 6 tests)
- src/renderer/hooks/useMaengguState.ts (modified: added moveTarget state)

**Decisions**:
- Separate movement/ directory for movement-related utilities
- moveTarget is nullable (null when not moving)
- Uses Math.random with floor for integer coordinates
- Bounds validation uses inclusive <= for edges
- getWindowBounds() provides window dimensions

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (29 tests, 6 new for target)
## 2025-01-25 - movement-vector

**PRD**: movement-vector (이동 벡터/속도)

**Completed**:
- calculateDirection(): computes dx/dy from two positions
- normalizeVector(): converts vector to unit length, handles zero vector safely
- scaleVector(): multiplies vector by scalar
- generateRandomSpeed(): random speed from MOVE_SPEED_RANGE (2-4 px/frame)
- calculateVelocity(): one-shot direction + normalization + speed application
- 16 comprehensive tests covering all edge cases

**Files**:
- src/renderer/movement/vector.ts (new)
- src/renderer/movement/vector.test.ts (new: 16 tests)

**Decisions**:
- Pure function utilities for composability
- Vector type with readonly dx/dy fields
- Zero vector handling prevents division by zero in normalization
- Speed generation uses Math.random with range mapping
- Tests cover positive/negative directions, zero cases, scaling

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (45 tests, 16 new for vector)
## 2025-01-25 - movement-step

**PRD**: movement-step (이동 프레임 업데이트)

**Completed**:
- useMovement hook: requestAnimationFrame-based position updates
- Calculates velocity using vector utilities
- Updates position every frame when isWalking=true
- Target reached detection: stops when distance < speed
- Speed generation on walk start (random 2-4 px/frame)
- Cleanup: cancels RAF on unmount or when walking stops
- Integrated with App.tsx: auto-generates target on walk-start, handles target reached
- 7 tests covering movement scenarios, cleanup, and edge cases

**Files**:
- src/renderer/hooks/useMovement.ts (new)
- src/renderer/hooks/useMovement.test.ts (new: 7 tests)
- src/renderer/App.tsx (modified: integrated useMovement, target generation, handleTargetReached)

**Decisions**:
- requestAnimationFrame for smooth 60fps movement
- Speed stored in ref (constant during one walk cycle)
- Target reached callback triggers force-idle transition
- Target auto-generated in useEffect when entering walk state with no target
- Real timers used for one test (RAF incompatible with fake timers)

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (52 tests, 7 new for useMovement)
## 2025-01-25 - movement-reach

**PRD**: movement-reach (목표 도달 판정)

**Completed**:
- Already implemented in movement-step task
- Distance-based reach detection: distanceToTarget < speed
- Exact target snap when reached (prevents overshoot)
- onTargetReached callback triggers idle transition
- handleTargetReached in App.tsx: clears moveTarget, dispatches force-idle

**Files**:
- src/renderer/hooks/useMovement.ts (lines 40-45: reach detection logic)
- src/renderer/App.tsx (lines 30-33: handleTargetReached callback)

**Decisions**:
- Reach threshold = current speed (adaptive based on movement speed)
- Snaps to exact target position on reach (no drift)
- Integrated with movement-step for cohesive implementation

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (52 tests, covered by useMovement tests)
## 2025-01-25 - movement-boundary

**PRD**: movement-boundary (경계 처리)

**Completed**:
- clampPositionToBounds(): ensures sprite stays fully visible on screen
- Accounts for sprite display size (64x64 = SPRITE_SIZE * 2)
- Updated generateRandomTarget(): targets never exceed valid bounds
- Integrated clamping in useMovement: every position update is clamped
- 6 comprehensive boundary tests (negative values, overflow, combined)

**Files**:
- src/renderer/movement/target.ts (modified: added clampPositionToBounds, updated generateRandomTarget)
- src/renderer/movement/target.test.ts (modified: 6 new boundary tests, updated existing tests)
- src/renderer/hooks/useMovement.ts (modified: clamp position on every update)

**Decisions**:
- Sprite-aware boundaries: maxX/maxY = bounds - SPRITE_DISPLAY_SIZE
- Math.max(0, Math.min(pos, max)) for clamping (clean, no conditionals)
- Clamp applied to all position updates (target generation + frame updates)
- Prevents sprite from going off-screen on any edge

**Feedback Loops**:
- typecheck: ✅ pass
- lint: ✅ pass (0 warnings, 0 errors)
- test: ✅ pass (58 tests, 6 new for boundary clamping)
